## **aula 13/08/24**
- estou doente
- instalar virtual box e linux mint no meu pc

# **Threads**
● Unidade básica de utilização da CPU;
● Composto por:
– ID;
– Contador de programa;
– Conjunto de registradores;
– Pilha.
![alt text](image.png)

● Um editor de texto:
– Thread para exibir interface gráfica;
– Thread para receber a entrada do usuário;
– Thread para corretor ortográfico;
– ...
● Processo com único thread
– Cada tarefa realizada por vez (perda de desempenho);

# ** Benefícios**
1) Capacidade de resposta:
– O programa continua a ser executado mesmo de parte
dele estiver bloqueada ou executando uma operação
demorada.
– Ex: Navegador internet baixando uma temporada de
uma série c/ 20GB

2) Compartilhamento de recursos:
– Em processos: memória compartilhada ou mensagens;
● Programador deve organizar;
– Em threads → compartilhamento implícito
● Programador não se preocupa

3) Economia de recursos
– Processo precisa de mais alocação de memória e recursos;
– Redução de *overhead*.

# **Programação multi-core**

● Processadores hoje em dia possuem vários núcleos (cores) de processamento;
● Vantagem na implementação de várias threads:
– Processo com 4 threads
![alt text](image-1.png)

● Processadores hoje em dia possuem vários
núcleos (cores) de processamento;
● Vantagem na implementação de várias threads:
– Processo com 4 threads – 1 Processador 2 Cores
![alt text](image-2.png)

# Alguns desafios

● Divisão de atividades:
● Equilíbrio;
● Divisão de dados;
● Dependência de dados;
● Teste e depuração.

# Modelos Multithreads

● Suporte de threads em dois níveis
– Threads de usuário: são as threads geradas pelos
processos em execução a nível de usuário
● Navegadores, editores de texto, jogos, etc...
– Threads de kernel: suportados e gerenciados pelo
SO – são as threads com atividades internas do núcleo.
● Gerência de processos, rotinas de drivers dos dispositivos,
etc

![alt text](image-3.png)

● As threads de usuário devem ser gerenciadas pelo
núcleo do sistema operacional. Essa gerência pode ser
feita de diversas formas através de modelos de
implementação de threads:
– Muitos-para-um
– Um-para-um
– Muitos-para-muitos

# Modelo Muitos-para-um

● Processo de usuário pode criar
muitos threads, mas que são
gerenciadas por um thread de
núcleo
● Na prática, é como se a
aplicação tivesse só 1 thread
● Fácil implementação (do SO)
● Como o núcleo só vê 1 thread
por processo a gerência
imposta ao SO é menor
![alt text](image-4.png)

● Desvantagens:
● Operações de entrada e saída (ES) são realizadas pelo núcleo:
– Logo, se um thread de um processo necessita acesso, todos
os outros threads ficam suspensos até o retorno da
operação de ES

● Threads do mesmo processo não executam em paralelo,
mesmo se houver processadores disponíveis
● O tempo de processador dado a cada processo é o mesmo,
independente de quantos threads cada processo possui

# Modelo um-para-um

● Um thread de usuário é mapeado
para um thread de núcleo
● Processo não é bloqueado por um
thread;
● Distribuição de tempo de
processamento mais justa
● Mais demorado
– Overhead de criação de thread de
kernel.

● Não escalável: existem um limite
no no de threads kernel

![Modelo um-para-um](image-5.png)

# Modelo muitos-para-muitos

● Mapeia um número x de
threads de usuário a um
número y de threads de
núcleo, com x > y
● Sem as deficiências dos
modelos anteriores.
– Permite execução paralela de
threads do mesmo processo;
– Redução de overhead;

![Modelo muitos-para-muitos](image-6.png)

# Comparativo de modelos de threads

![Comparativo de modelos de threads](image-7.png)

# Threads vs Cores

● Processadores podem ter um número x de cores e
um número y, com y >= x de threads
● Nesse caso, threads é uma virtualização do
núcleo de processamento
● Permite rodar mais processos de forma
‘simultânea’
– A execução real é somente no x cores, porém a
alternância entre os threads é extremamente rápida

● No Linux
– 8 Cpus
– 4 Núcleos
– 8/4 = 2 threads por núcleo

![no linux](image-8.png)

---
# **Escalonamento**

